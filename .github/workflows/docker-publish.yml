name: Build and push Docker images

# This workflow:
# - Builds images on all pushes and pull requests
# - Pushes images to GHCR for main branch, tags, AND pull requests
# - Tags PR images as "pr-{number}" for easy identification
# - Tags branch images as "{branch-name}" 
# - Tags all builds with "sha-{short-sha}"
# - Only tags "latest" for main branch and version tags

on:
  push:
    branches: ["**"]
    tags: ["v*.*.*"]
  pull_request:
    branches: ["**"]

permissions:
  contents: read
  packages: write

env:
  REGISTRY: ghcr.io

jobs:
  build-and-push:
    name: Build & Push ${{ matrix.name }}
    runs-on: ubuntu-latest
    concurrency:
      group: docker-publish-${{ github.ref }}-${{ matrix.name }}
      cancel-in-progress: true
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: frontend
            context: ./frontend
            dockerfile: ./frontend/Dockerfile
            image: nalamap-frontend
          - name: backend
            context: ./backend
            dockerfile: ./backend/Dockerfile
            image: nalamap-backend
          - name: nginx
            context: ./nginx
            dockerfile: ./nginx/Dockerfile
            image: nalamap-nginx

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        if: >-
          ${{ (github.event_name == 'push' && (github.ref == format('refs/heads/{0}', github.event.repository.default_branch) || startsWith(github.ref, 'refs/tags/'))) 
           || (github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository) }}
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ matrix.image }}
          flavor: |
            latest=${{ github.ref == format('refs/heads/{0}', github.event.repository.default_branch) || startsWith(github.ref, 'refs/tags/') }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha

      - name: Show generated tags
        run: |
          echo "Generated tags for ${{ matrix.name }}:"
          echo "${{ steps.meta.outputs.tags }}"

      - name: Build and push
        id: build
        uses: docker/build-push-action@v6
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.dockerfile }}
          platforms: linux/amd64
          push: >-
            ${{ (github.event_name == 'push' && (github.ref == format('refs/heads/{0}', github.event.repository.default_branch) || startsWith(github.ref, 'refs/tags/'))) 
             || (github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository) }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: |
            type=gha,scope=nalamap-${{ matrix.name }}
          cache-to: |
            type=gha,mode=max,scope=nalamap-${{ matrix.name }}

      - name: Export image metadata (tags + digest)
        if: always()
        env:
          META_TAGS: ${{ steps.meta.outputs.tags }}
          IMAGE_NAME: ${{ matrix.name }}
          IMAGE_FULL: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ matrix.image }}
          BUILD_DIGEST: ${{ steps.build.outputs.digest }}
          BUILD_REF: ${{ github.ref }}
          BUILD_SHA: ${{ github.sha }}
          BUILD_EVENT: ${{ github.event_name }}
          BUILD_OUTCOME: ${{ steps.build.outcome }}
        run: |
          set -eu
          mkdir -p image-metadata

          # Save tags (newline-separated) for the image
          printf '%s\n' "$META_TAGS" > "image-metadata/${IMAGE_NAME}-tags.txt"

          # Build metadata JSON safely via jq to handle special characters
          jq -n \
            --arg name    "$IMAGE_NAME" \
            --arg image   "$IMAGE_FULL" \
            --arg digest  "${BUILD_DIGEST:-}" \
            --arg ref     "$BUILD_REF" \
            --arg sha     "$BUILD_SHA" \
            --arg event   "$BUILD_EVENT" \
            --arg outcome "$BUILD_OUTCOME" \
            '{name: $name, image: $image, digest: $digest, ref: $ref, sha: $sha, event: $event, build_outcome: $outcome}' \
            > "image-metadata/${IMAGE_NAME}.json"

      - name: Upload image metadata artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: image-metadata-${{ matrix.name }}
          path: image-metadata/*
          if-no-files-found: error
          retention-days: 7

  dispatch-deploy:
    name: Dispatch deploy to infra repo
    runs-on: ubuntu-latest
    needs: build-and-push
    # Run even if some matrix builds failed — the infra repo decides whether
    # a partial set of images is deployable (e.g. only nginx changed).
    # Skip only when the entire workflow was cancelled.
    if: >-
      !cancelled()
      && (github.event_name == 'push' && (github.ref == format('refs/heads/{0}', github.event.repository.default_branch) || startsWith(github.ref, 'refs/tags/'))
         || github.event_name == 'pull_request')
    steps:
      - name: Download image metadata
        uses: actions/download-artifact@v4
        with:
          # Download only our image metadata artifacts from matrix jobs
          pattern: image-metadata-*
          path: image-metadata
          merge-multiple: true

      - name: Build payload and dispatch to infra
        uses: actions/github-script@v7
        env:
          CLOUD_INFRA_REPO_TOKEN: ${{ secrets.CLOUD_INFRA_REPO_TOKEN }}
        with:
          github-token: ${{ github.token }}
          retry-on-exit-code: 1
          script: |
            const fs = require('fs').promises;
            const path = require('path');

            // ── Helpers ──────────────────────────────────────────────

            /**
             * Sanitise & truncate a commit message so it is safe to embed
             * in a JSON payload dispatched to another repo.
             *
             * • strips control characters (except \n, \t)
             * • replaces lone surrogates / non-BMP oddities
             * • caps length at `maxLen` characters (default 500)
             */
            function sanitizeCommitMessage(raw, maxLen = 500) {
              if (!raw) return '';
              let msg = String(raw);
              // Remove control chars except newline (\n) and tab (\t)
              msg = msg.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '');
              // Truncate to avoid exceeding client_payload 10 KB limit
              if (msg.length > maxLen) {
                msg = msg.slice(0, maxLen) + '…[truncated]';
              }
              return msg;
            }

            async function collectImages(rootDir) {
              const images = [];
              let entries;
              try {
                entries = await fs.readdir(rootDir, { withFileTypes: true });
              } catch (err) {
                core.warning(`Could not read image-metadata directory: ${err.message}`);
                return images;
              }
              async function walk(current) {
                const entries = await fs.readdir(current, { withFileTypes: true });
                for (const entry of entries) {
                  const p = path.join(current, entry.name);
                  if (entry.isDirectory()) {
                    await walk(p);
                  } else if (entry.isFile() && entry.name.endsWith('.json')) {
                    const base = entry.name.replace(/\.json$/, '');
                    const tagsPath = path.join(current, `${base}-tags.txt`);
                    let meta;
                    try {
                      meta = JSON.parse(await fs.readFile(p, 'utf8'));
                    } catch (err) {
                      core.warning(`Skipping malformed metadata file ${p}: ${err.message}`);
                      continue;
                    }
                    let tags = [];
                    try {
                      const rawTags = await fs.readFile(tagsPath, 'utf8');
                      tags = rawTags.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
                    } catch {}
                    meta.tags = tags;
                    images.push(meta);
                  }
                }
              }
              await walk(rootDir);
              return images;
            }

            /**
             * POST with retry (exponential back-off) to handle transient
             * GitHub API / CDN errors (502, 503, 504, etc.).
             */
            async function fetchWithRetry(url, options, { retries = 3, baseDelay = 2000 } = {}) {
              for (let attempt = 1; attempt <= retries; attempt++) {
                const res = await fetch(url, options);
                if (res.ok) return res;
                const body = await res.text();
                if (attempt < retries && res.status >= 500) {
                  const delay = baseDelay * Math.pow(2, attempt - 1);
                  core.warning(`Dispatch attempt ${attempt}/${retries} failed (${res.status}). Retrying in ${delay}ms…`);
                  await new Promise(r => setTimeout(r, delay));
                  continue;
                }
                throw new Error(`Dispatch failed (attempt ${attempt}/${retries}): ${res.status} ${res.statusText}: ${body}`);
              }
            }

            // ── Main ─────────────────────────────────────────────────

            (async () => {
              const isPR = context.eventName === 'pull_request';
              const eventType = isPR ? 'deploy-preview' : 'deploy';
              const images = await collectImages('image-metadata');

              if (images.length === 0) {
                core.warning('No image metadata found. Skipping dispatch.');
                return;
              }

              // Summarise build outcomes
              const succeeded = images.filter(i => i.build_outcome === 'success');
              const failed    = images.filter(i => i.build_outcome !== 'success');
              core.info(`Images collected: ${images.length} total, ${succeeded.length} succeeded, ${failed.length} failed`);
              for (const img of failed) {
                core.warning(`Image "${img.name}" build outcome: ${img.build_outcome || 'unknown'}`);
              }

              // ── Commit message (safely) ──────────────────────────
              let commitMessage = '';
              if (isPR && context.payload.pull_request) {
                try {
                  const commitRes = await github.rest.repos.getCommit({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: context.payload.pull_request.head.sha,
                  });
                  commitMessage = commitRes.data.commit.message;
                } catch (error) {
                  core.warning(`Failed to fetch commit message: ${error.message}`);
                  commitMessage = context.payload.pull_request.title || '';
                }
              } else {
                commitMessage = context.payload.head_commit?.message || '';
              }
              commitMessage = sanitizeCommitMessage(commitMessage);

              const payload = {
                source_repository: `${context.repo.owner}/${context.repo.repo}`,
                ref: context.ref || process.env.GITHUB_REF,
                sha: context.sha || process.env.GITHUB_SHA,
                run_id: process.env.GITHUB_RUN_ID,
                run_attempt: process.env.GITHUB_RUN_ATTEMPT,
                pull_request: isPR ? (context.payload.pull_request?.number ?? null) : null,
                commit_message: commitMessage,
                images,
              };

              // Guard-rail: GitHub's client_payload limit is ~10 KB.
              const payloadJson = JSON.stringify(payload);
              const payloadSizeKB = (new TextEncoder().encode(payloadJson).length / 1024).toFixed(1);
              core.info(`Payload size: ${payloadSizeKB} KB`);
              if (payloadJson.length > 9500) {
                core.warning(`Payload is close to or exceeds the 10 KB client_payload limit (${payloadSizeKB} KB). Truncating commit_message further.`);
                payload.commit_message = sanitizeCommitMessage(commitMessage, 100);
              }

              const token = process.env.CLOUD_INFRA_REPO_TOKEN;
              if (!token) {
                core.info('CLOUD_INFRA_REPO_TOKEN not set. Skipping repository_dispatch to nalamap/cloud-infrastructure.');
                core.info(`Would have sent event '${eventType}' with ${images.length} images.`);
                return;
              }

              core.info(`Dispatching '${eventType}' with ${images.length} images…`);
              await fetchWithRetry('https://api.github.com/repos/nalamap/cloud-infrastructure/dispatches', {
                method: 'POST',
                headers: {
                  'Accept': 'application/vnd.github+json',
                  'Authorization': `token ${token}`,
                },
                body: JSON.stringify({
                  event_type: eventType,
                  client_payload: payload,
                }),
              });
              core.info('Dispatch successful.');
            })().catch(err => { core.setFailed(err.message); });

